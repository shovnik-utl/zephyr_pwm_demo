#include <inttypes.h>
#include <zephyr/kernel.h>

/* 1. Include the relevant headers for pwm. */
#include <zephyr/device.h>
#include <zephyr/drivers/pwm.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(Lesson4_Exercise1, LOG_LEVEL_INF);

/* 2. Define fading parameters. */
#define NUM_STEPS   50U
#define SLEEP_MSEC  25U

/* 3a. Get the node identifier for [] through its alias. */
#define PWM_LED0     DT_ALIAS(pwm_led0)

/* 3b. Initialize and populate struct pwm_dt_spec. */
static const struct pwm_dt_spec pwm_led0 = PWM_DT_SPEC_GET(PWM_LED0);

int main(void)
{
    int err = 0;
    uint32_t pulse_width = 0U;
    uint32_t step = pwm_led0.period / NUM_STEPS;
    bool fading = false;

    /* 4. Check if the device is ready. */
    if (!pwm_is_ready_dt(&pwm_led0)) {
        LOG_ERR("Error: PWM device %s is not ready", pwm_led0.dev->name);
        return 0;
	}

    /* Once started, the PWM signal will be generated by the PWM peripheral
       within the SoC independent of the CPU - meaning you can use the CPU
       to do other work in parallel. */
    for (;;) {
		err = pwm_set_pulse_dt(&pwm_led0, pulse_width);
		if (err) {
			LOG_ERR("%d: failed to set pulse width\n", err);
			return 0;
		}
		if (!fading) {
			pulse_width += step;
			if (pulse_width >= pwm_led0.period) {
				pulse_width = pwm_led0.period - step;
				fading = true;
			}
		} else {
			if (pulse_width >= step) {
				pulse_width -= step;
			} else {
				pulse_width = step;
				fading = false;
			}
		}
		k_sleep(K_MSEC(SLEEP_MSEC));
    }
    
    return 0;
}