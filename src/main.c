#include <zephyr/kernel.h>

/* 1. Include the relevant headers for pwm. */
#include <zephyr/device.h>
#include <zephyr/drivers/pwm.h>

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(Lesson4_Exercise1, LOG_LEVEL_INF);

/* 2. Define the desired PWM period and pulse */
#define PWM_PERIOD_NS   100000000
#define PWM_DUTY_CYCLE  14000000

/* 3a. Get the node identifier for [] through its alias. */
#define PWM_LED0     DT_ALIAS(pwm_led0)

/* 3b. Initialize and populate struct pwm_dt_spec. */
static const struct pwm_dt_spec pwm_led0 = PWM_DT_SPEC_GET(PWM_LED0);

int main(void)
{
    int err;

    /* 4. Check if the device is ready. */
    if (!pwm_is_ready_dt(&pwm_led0)) {
        LOG_ERR("Error: PWM device %s is not ready", pwm_led0.dev->name);
        return 0;
	}
    
    /* 5. - Control the LED with the control signal generated from the PWM */
    err = pwm_set_dt(&pwm_led0, PWM_PERIOD_NS, PWM_DUTY_CYCLE);
    if (err) {
	    LOG_ERR("Error in pwm_set_dt(), err: %d", err);
	    return 0;
    }

    /* Once started, the PWM signal will be generated by the PWM peripheral
       within the SoC independent of the CPU - meaning you can use the CPU
       to do other work in parallel. */
    for (;;) {
        LOG_INF("Hello PWM!");
        k_msleep(1000); /* For now just log a message every 1000 ms. */
    }
    
    return 0;
}